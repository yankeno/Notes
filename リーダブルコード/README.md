# 2 章 名前に情報を詰め込む

## 名前の長さを決める

- スコープが小さい場合はコードの文脈から短い名前でも意味が通じやすい
- スコープが大きいグローバル変数などの場合は短い名前では通じないためできるだけ情報を詰め込む

# 3 章 誤解されない名前

## 範囲を指定する時は first と last を使う

- 包含的範囲指定: first/last, max/min
- 排他的範囲指定: begin/end

# 4 章 美しさ

## 一貫性のある適切な改行位置

```java
/************************************
 問題点: 改行位置、コメントが一貫していない
 ************************************/
class PerformanceTester{
  public static final wifiSimulator = new TcpConnectionSimulator(
    500, /* Kbps */
    90, /* millisecs latency */
    200, /* jitter */
    1 /* packet loss */
  );

  public static final t3FiberSimulator =
  new TcpConnectionSimulator(
    45000, /* Kbps */
    10, /* millisecs latency */
    0, /* jitter */
    0 /* packet loss */
  );

  public static final cellSimulator = new TcpConnectionSimulator(
    100, /* Kbps */
    400, /* millisecs latency */
    250, /* jitter */
    5 /* packet loss */
  );
}

/************************************
 改善例: シルエットに一貫性をもたせる
************************************/
class PerformanceTester{
  public static final wifiSimulator =
  new TcpConnectionSimulator(
    500,    /* Kbps */
    90,     /* millisecs latency */
    200,    /* jitter */
    1       /* packet loss */
  );

  public static final t3FiberSimulator =
  new TcpConnectionSimulator(
    45000,  /* Kbps */
    10,     /* millisecs latency */
    0,      /* jitter */
    0       /* packet loss */
  );

  public static final cellSimulator =
  new TcpConnectionSimulator(
    100,    /* Kbps */
    400,    /* millisecs latency */
    250,    /* jitter */
    5       /* packet loss */
  );
}
```

## 個人的な好みと一貫性

- 個人的な好みや正しさよりも`一貫性`を優先する
- 一部だけ正しいスタイルで書かれているコードよりは、間違ったスタイルを使っているけれど一貫性のあるコードが読みやすい

# 5 章 コメントすべきことを知る

## コメントするべきでは「ない」こと

- コードを読めば`すぐに`わかること
  - ただし、以下のように初見で瞬時に何をしているのかわかりづらいものについては、コメントを書くことでプログラムを読む時間を短くすることができる

```python
# 2番目の '*' 以降を全て削除する
name = '*'.join(line.split('*')[:2])
```

- コメントのためのコメント

```csharp
/************************************
 問題点: 関数名とほぼ同義になっている
 ************************************/
// 与えられたsubtreeに含まれるnameとdepthに合致したNodeを見つける
Node* FindNodeInSubtree(Node* subtree, string name, int depth){
  // 処理
}

/************************************
 改善例: 関数名から読み取れない情報を書く
************************************/
// 与えられたnameに合致したNodeかNULLを返す
// もし depth <= 0 ならば、'subtree' だけを調べる。
// もし depth == N ならば、'subtree' とその下のN階層まで調べる
Node* FindNodeInSubtree(Node* subtree, string name, int depth){
  // 処理
}
```

- ひどい名前はコメントで補完せず名前自体を変える

## コメントすべきこと

- `なぜ`他の実装方法ではなくこうなっているのか(Why)
- コードの欠陥

```php
// TODO: もっと高速なアルゴリズムを使う
```

<よく使われる記法>

| 記法   | 典型的な意味               |
| ------ | -------------------------- |
| TODO:  | あとで手を付ける           |
| FIXME: | 既知の不具合があるコード   |
| HACK:  | あまりキレイじゃない解決策 |
| XXX:   | 危険! 大きな問題がある     |

- 定数にコメントをつける

```php
/************************************
 問題点: 定数が決まった背景がわからない
 ************************************/
const NUM_THREADS = 8;
const int MAX_RSS_SUBSCRIPTIONS = 1000;
const IMAGE_QUALITY = 0.72;

/************************************
 改善例: 値を決めた理由を記載する
************************************/
// 値は「>= 2 * num_processors」で十分
const NUM_THREADS = 8;
// 合理的な限界値。人間はこんなに読めない。
const MAX_RSS_SUBSCRIPTIONS = 1000;
// 0.72ならユーザはファイルサイズと品質の面で妥協できる
const IMAGE_QUALITY = 0.72;
```

## 読み手に向けたコメント

- 疑問に思いそうな部分を予想してコメントする
- ファイルやクラスの`全体像を説明する`コメント
- コードブロックで何をしているのかを説明するコメント

# 6 章 コメントは正確で簡潔に

## 歯切れの悪い文章を磨く

- 以下のような文章ではどのように変わるかが言及されていない

```php
// コレまでにクロールしたURLかどうかによって優先度を変える
```

- コチラのほうが簡潔でわかりやすい

```php
// これまでにクロールしていないURLの優先度を高くする
```

-> ド・モルガンの定理などを使用して言い換えればわかりやすくなる場合もあるかも

## 入出力のコーナーケースに実例を使う

- 曖昧さがあり、読み手が疑問を感じてしまう部分があるコメント。以下のような疑問が出てしまうことが予想される。
  - char は除去する文字列か、順序のない文字集合か？
  - src の末尾に複数の chars があったらどうなるのか？

```java
// 'src' の先頭や末尾にある 'chars' を除去する
String Strip(String src, String chars) {...}
```

- 上記の疑問に答えられるコメント

```java
// 実例：Strip("abba/a/ba", "ab") は "a" を返す
String Strip(String src, String chars) {...}
```

-> 読み手としては特殊なデータが来たときの動作が気になるので、なるべく特殊パターンの場合どういう動作になるのかがわかる実例を示す

# 7 章 制御フローを読みやすくする

## 条件式の引数の並び順

- 自然言語の順番と合わせたほうがわかりやすい
  - ex. もしのび太がテストで 30 点以上取ったら〜

| 左側                   | 右側                           |
| ---------------------- | ------------------------------ |
| 調査対象の式。変化する | 比較対象の式。あまり変化しない |

- `if` の条件部分で代入できる言語では、比較と代入を誤ってしまうバグを防ぐため、引数の並びを変えるプログラマもいる

```cpp
if (obj = NULL) ...     // このように書いている場合
if (obj == NULL) ...    // これを意図していたバグである事が多い
if (NULL == obj) ...    // 引数を入れ替えて防ぐ(NULLに代入はできない)
```

-> ヨーダ記法というらしい。最近のコンパイラは `if` 内で代入すると警告を出してくれるので、ヨーダ記法は必要なさそう。

## if/else ブロックの並び順

- 否定形よりも肯定形を使う  
  -> これは意識してる
- 単純な条件を先に書く
  - `if` と `else` を両方見渡せるので読みやすい  
    -> あまり徹底できていない
- 関心を引く条件や目立つ条件を先に書く  
  -> 考えたことなかった

## 三項演算子

- 基本的には `if/else` を使用する
- 三項演算子を使用することで簡潔になるならば使用する

## 関数から早く返す

- 複数の `return` があってもよい
- `ガード節`は積極的に使用する

## ネストを浅くする

- `if` の中に更に `if` を追加するようなとき、1 歩下がって俯瞰する
  - 失敗ケースを早めに `return` する

# 8 章 巨大な式を分割する

## 説明変数

- 名前を与えることで何を意味しているのかがわかりやすくなる

```php
// こう書くとなんのことかわからない
if (trim($params[0] === 'root')) {
    // 処理
}

// 説明変数を追加することでユーザ名を意味しているということがわかりやすくなる
$username = trim($params[0] === 'root');
if ($username === 'root') {
    // 処理
}
```

## 要約変数

- コードの塊を小さな名前に置き換えることで意図が伝わりやすくなる

```php
// 編集可否が何によって判断されているのかがわかりづらい
if ($request->user->id === $document->owner->id) {
    // 編集可能
}

if ($request->user->id !== $document->owner->id) {
    // 読み取り専用
}

// 要約変数を追加することで何故編集可能なのかがわかりやすくなる
$userOwnsDocument = ($request->user->id === $document->owner->id);

if ($userOwnsDocument) {
    // 編集可能
}

if (!$userOwnsDocument) {
    // 読み取り専用
}
```

# 9 章 変数と読みやすさ

## 変数を削除する

- 役に立たない一時変数を削除する
  - 説明変数や要約変数でない
  - 1 度しか使用していない
- コード修正の過程で既存変数が「役に立たない」ものになったら削除する

## 中間結果を削除する

- 中間結果を保持するためだけに存在している変数は削除可能
- 関数からはなるべく早く結果を返すほうがいい  
  -> 読み手の負担も減る

## 制御フロー変数を削除する

- 制御フロー変数は大抵の場合 break や continue を使用することで削除可能

```java
// 制御フロー変数はこんなやつ
boolean done = false;

while (/* 条件 */ && !done) {
    // 処理

    if (...) {
        done = true;
        continue;
    }
}
```

## 変数のスコープを小さくする

- 変数が大量に出てくると現在値を覚えておく数が増え、読み手の負担が増加する
- なるべく`スコープを縮めて`、考えなければならない変数の数を少なくする

## 変数には 1 度だけ書き込む(=immutable にする)

- 変数が何度も書き換わると現在値の把握が難しくなり、読み手の負担が増加する
- 変数に`書き込む回数を(できれば 1 回に)減らす`

# 10 章 無関係の下位問題を抽出する

## 低レベルの目標を抽出する

- 高レベルの目標に直接関係していない低レベルの問題(※)を見つけて汎用的な関数に切り出す  
  (※)綺麗に画面表示する、差分を計算する などを解決している部分は大体低レベルの問題に該当する

## 既存のインタフェースを簡潔にする

- ライブラリのインタフェースが美しくないのであれば、`ラップ関数`を作って綺麗に使えるようにする

# 13 章 短いコードを書く

## 身近なライブラリに親しむ

- 標準ライブラリに目を通しておく
  - 標準ライブラリとして実装されているのに、それを知らず自分でコードを書いてしまうケースが非常に多い
  - 設計・修正・テストなどを全て自分でやる必要があり、非常に非効率

# 15 章 「分・時間カウンタ」を設計・実装する

## メモリ使用量について

- メモリ使用量は予測可能なように実装する
