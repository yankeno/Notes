# 2 章 エンドポイントの設計とリクエストの形式

## GET メソッド

- GET メソッドでデータの更新をできるようにしてはいけない
- Google のクローラも GET でリクエストを飛ばしてくる

## POST メソッド

- 新しいリソースの登録に使用する
- 更新、削除には使用しない

## PUT メソッド

- 既存のリソースの更新に使用する
- リクエストには更新したいリソースの URI を指定する
- リクエストしたデータでリソースを置き換える

<u>_POST と PUT の違い_</u>

```text
[POST] https://api.example.com/v1/friends
-> 配下に新しいデータを登録する

[PUT]  https://api.example.com/v1/friends/12345
-> 指定したデータそのものを更新する
```

### PATCH メソッド

- リソースの一部を更新する

## リソースにアクセスするためのエンドポイント設計の注意点

- 複数形の名詞を利用する
- エンコードが必要な文字を使わない
- 単語はハイフンつなぎにする

# 3 章 レスポンスデータの設計

## データフォーマットには何を使うか

- かつてはデータのやり取りは XML という選択肢しか無かった
- 現在では JSON に完全に置き換わった
  - 理由としてはシンプルさ、データサイズが小さい、JS との相性が良いことが挙げられる

## データの内部構造の考え方

- リクエスト回数がなるべく少なくなるように設計する
  - エンドポイントを利用するクライアントが何をしたいのかを予測して、必要な情報を返す
  - 例えば友人一覧を取得するエンドポイントの場合、クライアント側でやりたいこととしては友人一覧を画面に表示する、といったことが考えられる
  - そのためレスポンスは ID だけを返すのではなく、名前やプロフィールアイコンも併せて返すようにする(名前やプロフィール取得のために別のエンドポイントにリクエストさせるような設計にしない)
- エンベロープは使用せず、ヘッダーを使用する
- データは階層構造を持たせた方がわかりやすい場合は階層構造にし、基本的にはフラットにする

## 各データのフォーマット

- データの名前はスネークケースやキャメルケース等一般的なものならなんでもいいが API で統一する
- 日付は RFC3339 の仕様に準拠する

```text
2024-04-28T13:00:00+09:00
```

## エラーの表現

- 適切なステータスコードを使用する
- ステータスコードだけではエラーの詳細までは判別できないため、ボディにエラーの詳細情報を入れて返す
  - 最低限以下があれば OK
    - エラーの詳細コード(独自定義)
    - 詳細情報のリンク
- エラー発生時にむやみに HTML を返さない

# 4 章 HTTP の仕様を最大限利用する

## ステータスコードを正しく使う

### 正しいステータスコードを使うべき理由

- そもそも API の利用者には 200 番台はリクエスト成功、400/500 番台は失敗といった共通認識があるので、すべてのレスポンスのステータスコードを 200 にするといった設計にした場合、混乱を招く
- HTTP のクライアントライブラリは基本的にステータスコードを見て大まかな振る舞いを決めるため、適切でないステータスコードを返した場合に問題を引き起こす可能性がある

### 200 番台

- DELETE でリソースを削除した場合は空のレスポンスとともに 204 を返す
- PUT や PATCH でデータを更新した場合は更新後のリソースとともに 200 を返す

### 300 番台

- 公開されている API を提供する場合、クライアント側の実装によってはリダイレクトの発生を予期していない可能性も十分にある
- リダイレクトが起こりうるケースがわかっている場合にはドキュメントに明記する

### 400 番台

- 400 はその他のような扱いで、400 番台の他のステータスコードに該当しないエラーに使用する
- 401:誰やお前、403:お前はこの操作できんやろ
- 404 を返す際には何が見つからなかったのかも併せて返してあげる
- 410 は 404 と違い、かつて存在したけど今は存在しないことを意味する
  - メールアドレスで検索を行う場合などはセキュリティの観点でレスポンスとして使用しない方がいい
- ジョークで作られたステータスコードも存在する

### 500 番台

- 500 番台のエラーはログを出力して、管理者に通知が行くように設定する
- 発生した場合は再発防止を行う

## メディアタイプの指定

- トップレベルタイプ名は基本的に application を使用する
- text はサブタイプの形式(例えば xml)に関する前提知識がないユーザーが読んで理解できるものに使用する
- 正しいメディアタイプを設定していないとクライアント側がレスポンスを正しく理解できない
- サブタイプが x から始まるものは新しく登場したデータ形式、あまり一般的でないデータ形式、 [IANA](https://www.iana.org/assignments/media-types/media-types.xhtml) に登録されていないという意味
  - 一部例外的に x から始まり IANA に登録されているものもある
- 独自のメディアタイプを定義するさいに x から始まるメディアタイプを定義すべきではない
  - 2013 年 1 月以降は、x から始まるメディアタイプを「未登録のメディアタイプ」を表すものとはみなされなくなった
- 基本的には IANA に登録されているものを使用し、新たなメディアタイプが必要な場合は vnd から始まるベンダツリーを使用して定義する
- 不正なメディアタイプを指定してしまうとセキュリティ上のリスクもある
- リクエストの際には Content-Type でリクエストボディの形式を指定、Accept でレスポンスとして欲しいメディアタイプを指定する
- Accept には複数のメディアタイプとその優先度を指定できるが、そもそも欲しいメディアタイプだけを Accept に指定すればよい

## メモ

- 単語の連結はなるべく避ける
  - 繋げる場合はハイフン繋ぎ
- クエリパラメータとパスパラメータの使い分けは、リソースか否か
  - ユーザー ID などは一意なリソースを表すために必要であるためパスパラメータ
  - 検索の際の offset、limit、page はクエリパラメータ
- envelope(封筒 = データをくるむための構造)はなるべく使用せず、ヘッダーを使用する
- バージョニングのルールとして広く知られるものとして[セマンティックバージョニング](https://semver.org/lang/ja/)がある

## まとめ

- 独自仕様はなるべく避け、HTTP の仕様に準ずる

## 記事 URL

https://qiita.com/lvn-okino/items/df16b0922dff67443d38

## 参考

### 書籍

- [Web API: The Good Parts](https://amzn.asia/d/ilfvNuk)
- [Web を支える技術 ―― HTTP，URI，HTML，そして REST](https://amzn.asia/d/5igQxIT)
- [体系的に学ぶ 安全な Web アプリケーションの作り方 脆弱性が生まれる原理と対策の実践](https://amzn.asia/d/8ltzzZN)

### URL

- [MDN HTTP](https://developer.mozilla.org/ja/docs/Web/HTTP)
- [Twitter API](https://developer.twitter.com/en/docs/api-reference-index)
- [GitHub API](https://docs.github.com/ja/rest/pulls/reviews?apiVersion=2022-11-28)
- [Notion API](https://developers.notion.com/reference/intro)
- [YouTube Data API ](https://developers.google.com/youtube/v3/docs?hl=ja)
- [LINE Messaging API](https://developers.line.biz/ja/reference/messaging-api/)
- [Rakuten Webservice](https://webservice.rakuten.co.jp/documentation)
- [Qiita API](https://qiita.com/api/v2/docs)
